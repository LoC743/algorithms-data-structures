# Отчет

## Урок 3. Поиск в массиве. Простые сортировки

### 1. Попробовать оптимизировать пузырьковую сортировку. Сравнить количество операций сравнения оптимизированной и не оптимизированной программы. Написать функции сортировки, которые возвращают количество операций.

Пузырьковая сортировка:

```c
void bubble_sort(int* array, int size) {
    for (int i = 0; i < size - 1; ++i) {
        for (int j = 0; j < size - 1; ++j) {
            if (array[j] > array[j + 1]) {
                swap(&array[j], &array[j + 1]);
            }
        }
    }
}
```

Оптимизированная пузырьковая сортировка:

```c
void bubble_sort_optimized(int* array, int size) {
    for (size_t i = 0; i + 1 < size; ++i) {
        for (size_t j = 0; j + 1 < size - i; ++j) {
            if (array[j + 1] < array[j]) {
                swap(&array[j], &array[j + 1]);
            }
        }
    }
}
```

Сравнение производительности:

| Название сортировки                     | Размер массива | Количество выполненных операций | Затраченное время (с) |
| --------------------------------------- | -------------- | ------------------------------- | --------------------- |
| Пузырьковая сортировка                  | 10             | 105                             | 0.000010              |
| Оптимизированная пузырьковая сортировка | 10             | 69                              | 0.000003              |
| Пузырьковая сортировка                  | 100            | 12238                           | 0.000169              |
| Оптимизированная пузырьковая сортировка | 100            | 7387                            | 0.000095              |
| Пузырьковая сортировка                  | 1000           | 1235648                         | 0.009682              |
| Оптимизированная пузырьковая сортировка | 1000           | 737147                          | 0.005943              |
| Пузырьковая сортировка                  | 10000          | 124533188                       | 0.395491              |
| Оптимизированная пузырьковая сортировка | 10000          | 74548187                        | 0.251823              |
| Пузырьковая сортировка                  | 100000         | 12476147512                     | 41.525681             |
| Оптимизированная пузырьковая сортировка | 100000         | 7476297511                      | 30.438166             |

#### Сложность по времени:

Худшее время: **O(n<sup>2</sup>)**

Среднее время: **O(n<sup>2</sup>)**

Лучшее время: **O(n)**

#### Затраты памяти: **Без оптимизации: O(1). С оптимизацией: O(2)**

### 2. Реализовать шейкерную сортировку.

Сортировка перемешиванием(шейкерная сортировка):

```c
void shaker_sort(int* array, int size) {
    int left = 0;
    int right = size - 1;

    while(left <= right) {
        for (int i = right; i > left; --i) {
            if (array[i - 1] > array[i]) {
                swap(&array[i - 1], &array[i]);
            }
        }
        ++left;
        for (int i = left; i < right; ++i) {
            if (array[i] > array[i + 1]) {
                swap(&array[i], &array[i + 1]);
            }
        }
        --right;
    }
}
```

Сравнение производительности:

| Название сортировки  | Размер массива | Количество выполненных операций | Затраченное время (с) |
| -------------------- | -------------- | ------------------------------- | --------------------- |
| Шейкерная сортировка | 10             | 72                              | 0.000008              |
| Шейкерная сортировка | 100            | 7316                            | 0.000141              |
| Шейкерная сортировка | 1000           | 738875                          | 0.006343              |
| Шейкерная сортировка | 10000          | 74734419                        | 0.291284              |
| Шейкерная сортировка | 100000         | 7467257243                      | 26.997703             |

#### Сложность по времени:

Худшее время: **O(n<sup>2</sup>)**

Среднее время: **O(n<sup>2</sup>)**

Лучшее время: **O(n)**

#### Затраты памяти: **O(1)**

### 3. Реализовать бинарный алгоритм поиска в виде функции, которой передается отсортированный массив. Функция возвращает индекс найденного элемента или -1, если элемент не найден.

Реализация алгоритма бинарного поиска(рекурсивно):

```c
int binary_search_recursive(int* array, int left, int right, int search) {
    if (right >= left) {
        int mid = left + (right - left) / 2;

        if (array[mid] == search)
            return mid;
        if (array[mid] > search)
            return binary_search_recursive(array, left, mid - 1, search);

        return binary_search_recursive(array, mid + 1, right, search);
    }
    return -1;
}
```

Реализация алгоритма бинарного поиска(итеративно):

```c
int binary_search(int* array, int left, int right, int search) {
    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (array[mid] == search)
            return mid;
        if (array[mid] < search)
            left = mid + 1;
        else
            right = mid - 1;
    }
    return -1;
}
```

#### Сложность по времени:

Худшее время: **O(log n)**

Среднее время: **O(log n)**

Лучшее время: **O(1)**

#### Затраты памяти:

Итеративный подход: **O(1)**

Рекурсивный подход: **O(log n)**

### 4. Подсчитать количество операций для каждой из сортировок и сравнить его с асимптотической сложностью алгоритма.

#### Пузырьковая сортировка

Реализация пузырьковой сортировки:

```c
void bubble_sort(int* array, int size) {
    for (int i = 0; i < size - 1; ++i) {
        for (int j = 0; j < size - 1; ++j) {
            if (array[j] > array[j + 1]) {
                swap(&array[j], &array[j + 1]);
            }
        }
    }
}
```

Реализация оптимизированной пузырьковой сортировки:

```c
void bubble_sort_optimized(int* array, int size) {
    for (size_t i = 0; i + 1 < size; ++i) {
        for (size_t j = 0; j + 1 < size - i; ++j) {
            if (array[j + 1] < array[j]) {
                swap(&array[j], &array[j + 1]);
            }
        }
    }
}
```

| Цикл               | Количество сравнений |
| ------------------ | -------------------- |
| 1                  | (n - 1)              |
| 2                  | (n - 2)              |
| 3                  | (n - 2)              |
| ...                | ...                  |
| последняя итерация | 1                    |

Таким образом получается, что количество сравнений: `(n - 1) + (n - 2) + (n - 3) + ... + 1 = n(n - 1) / 2`

То есть, примерно равно n<sup>2</sup>

#### Сортировка перемешиванием(шейкерная сортировка):

Реализация шейкерной сортировки:

```c
void shaker_sort(int* array, int size) {
    int left = 0;
    int right = size - 1;

    while(left <= right) {
        for (int i = right; i > left; --i) {
            if (array[i - 1] > array[i]) {
                swap(&array[i - 1], &array[i]);
            }
        }
        ++left;
        for (int i = left; i < right; ++i) {
            if (array[i] > array[i + 1]) {
                swap(&array[i], &array[i + 1]);
            }
        }
        --right;
    }
}
```

Шейкерная сортировка является разновидностью пузырьковой сортировки.

| Цикл               | Количество сравнений |
| ------------------ | -------------------- |
| 1                  | (n - 1)              |
| 2                  | (n - 2)              |
| 3                  | (n - 2)              |
| ...                | ...                  |
| последняя итерация | 1                    |

Таким образом получается, что количество сравнений: `(n - 1) + (n - 2) + (n - 3) + ... + 1 = n(n - 1) / 2`

То есть, примерно равно n<sup>2</sup>

#### Сортировка вставками

Реализация сортировки вставками:

```c
void insertion_sort(int* array, int size) {
    for (size_t i = 1; i < size; ++i) {
        int item = array[i];
        size_t j = i;

        while(j > 0 && array[j - 1] > item) {
            array[j] = array[j - 1];
            --j;
        }

        array[j] = item;
    }
}
```

В _худшем случае_ - каждый элемент массива должен сравниваться с каждыми другими элементами, поэтому для каждого элемента будет произведено `n - 1` сравнений.

Поэтому общее количество сравнений: `n(n - 1) ~` n<sup>2</sup>

В _лучшем случае_ - массив будет уже отсортирован, поэтому цикл просто пройдет по элементам и не будет заходить во внутренний цикл.

#### Сортировка методом выбора

Реализация сортировки методом выбора:

```c
void selection_sort(int* array, int size) {
    for (size_t i = 0; i < size - 1 ; ++i) {
        size_t min_index = i;
        for (size_t j = i + 1; j < size; ++j) {
            if (array[j] < array[min_index]) {
                min_index = j;
            }
        }
        swap(&array[min_index], &array[i]);
    }
}
```

| Цикл               | Количество сравнений |
| ------------------ | -------------------- |
| 1                  | (n - 1)              |
| 2                  | (n - 2)              |
| 3                  | (n - 2)              |
| ...                | ...                  |
| последняя итерация | 1                    |

Таким образом получается, что количество сравнений: `(n - 1) + (n - 2) + (n - 3) + ... + 1 = n(n - 1) / 2`

То есть, примерно равно n<sup>2</sup>

#### Сравнение производительности алгоритмов

Размер массива **10**:

| Название сортировки       | Количество выполненных операций | Затраченное время (с) |
| ------------------------- | ------------------------------- | --------------------- |
| Пузырьковая сортировка    | 73                              | 0.000008              |
| Шейкерная сортировка      | 73                              | 0.000005              |
| Сортировка вставками      | 55                              | 0.000002              |
| Сортировка методом выбора | 67                              | 0.000003              |

Размер массива **100**:

| Название сортировки       | Количество выполненных операций | Затраченное время (с) |
| ------------------------- | ------------------------------- | --------------------- |
| Пузырьковая сортировка    | 7274                            | 0.000101              |
| Шейкерная сортировка      | 7274                            | 0.000093              |
| Сортировка вставками      | 2621                            | 0.000023              |
| Сортировка методом выбора | 5357                            | 0.000031              |

Размер массива **1000**:

| Название сортировки       | Количество выполненных операций | Затраченное время (с) |
| ------------------------- | ------------------------------- | --------------------- |
| Пузырьковая сортировка    | 749173                          | 0.006888              |
| Шейкерная сортировка      | 749173                          | 0.006868              |
| Сортировка вставками      | 252670                          | 0.001519              |
| Сортировка методом выбора | 505767                          | 0.002834              |

Размер массива **10000**:

| Название сортировки       | Количество выполненных операций | Затраченное время (с) |
| ------------------------- | ------------------------------- | --------------------- |
| Пузырьковая сортировка    | 75123762                        | 0.305601              |
| Шейкерная сортировка      | 75123762                        | 0.247132              |
| Сортировка вставками      | 25158759                        | 0.060941              |
| Сортировка методом выбора | 50068347                        | 0.109365              |

Размер массива **100000**:

| Название сортировки       | Количество выполненных операций | Затраченное время (с) |
| ------------------------- | ------------------------------- | --------------------- |
| Пузырьковая сортировка    | 7497763982                      | 31.467005             |
| Шейкерная сортировка      | 7497763982                      | 28.030753             |
| Сортировка вставками      | 2498113979                      | 6.021995              |
| Сортировка методом выбора | 5000698037                      | 10.795644             |

_Вычисления выполнялись на случайно сгенерированных массивах_

Таблица сложности алгоритомов:

| Название сортировки       | Худшее время     | Среднее время    | Лучшее время     | Использование памяти       |
| ------------------------- | ---------------- | ---------------- | ---------------- | -------------------------- |
| Пузырьковая сортировка    | O(n<sup>2</sup>) | O(n<sup>2</sup>) | O(n)             | O(1), с оптимизациями O(2) |
| Шейкерная сортировка      | O(n<sup>2</sup>) | O(n<sup>2</sup>) | O(n)             | O(1)                       |
| Сортировка вставками      | O(n<sup>2</sup>) | O(n<sup>2</sup>) | O(n)             | O(1)                       |
| Сортировка методом выбора | O(n<sup>2</sup>) | O(n<sup>2</sup>) | O(n<sup>2</sup>) | O(1)                       |
